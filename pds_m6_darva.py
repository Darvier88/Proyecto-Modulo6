# -*- coding: utf-8 -*-
"""PDS_M6_DARVA.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1q0DPRLgCBH0xqWtg5O1O629pUox3IMrj
"""

import json
import glob
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from pathlib import Path

DATA_DIR = Path("/content/")

json_paths = {
    "destinos_ids": DATA_DIR / "destinos_ids.json",
    "manta": DATA_DIR / "manta_data.json",
    "salinas": DATA_DIR / "salinas_data.json",
    "montañita": DATA_DIR / "montañita_data.json",
    "puerto_lopez": DATA_DIR / "puerto_lópez_data.json",
    "general_villamil": DATA_DIR / "general_villamil_data.json",
    "ayampe": DATA_DIR / "ayampe_data.json",
    "atacames": DATA_DIR / "atacames_data.json"
}

data_raw = {}

for key, file_path in json_paths.items():
    with open(file_path, "r", encoding="utf-8") as f:
        content = json.load(f)
        data_raw[key] = content

records = []

for key, content in data_raw.items():
    if "alojamientos" not in content:
        continue  # destinos_ids.json no tiene alojamientos

    destino = content["destino"]

    for aloj in content["alojamientos"]:
        records.append({
            "destino": destino,
            "title": aloj.get("title"),
            "price": aloj.get("price"),
            "rating": aloj.get("rating"),
            "dist_centro_km": aloj.get("distance"),
            "description": aloj.get("description"),
            "services":aloj.get("services", []),
            "reviews": aloj.get("reviews", []),
            "features": aloj.get("features", [])
        })

df = pd.DataFrame(records)

df

df["price"] = (
    df["price"]
    .str.replace("US$", "", regex=False)
    .str.replace(".", "", regex=False)
    .str.replace(",", ".", regex=False)
    .astype(float)
)

df["rating"] = (
    df["rating"]
    .replace({"Sin puntuación": np.nan})
    .str.replace(",", ".", regex=False)
    .astype(float)
)

df["dist_centro_km"] = (
    df["dist_centro_km"]
    .str.extract(r"(\d+,\d+|\d+\.\d+|\d+)")
    [0]
    .str.replace(",", ".", regex=False)
    .astype(float)
)

# Umbrales basados en terciles
q1 = df["price"].quantile(0.33)
q2 = df["price"].quantile(0.66)

def categorize_price(p):
    if p <= q1: return "accesible"
    elif p <= q2: return "estandar"
    else: return "premium"

df["categoria"] = df["price"].apply(categorize_price)

def has_pool(services):
    return any("piscina" in s.lower() for s in services)

def has_breakfast(features, services):
    text = (features or "") + " " + " ".join(services)
    return "desayuno" in text.lower()

def has_beachfront(services):
    return any("frente a la playa" in s.lower() for s in services)

df["pool"] = df["services"].apply(has_pool)
df["breakfast"] = df.apply(lambda r: has_breakfast(r["features"], r["services"]), axis=1)
df["beachfront"] = df["services"].apply(has_beachfront)

"""**Capacidad Hospitalaria (CH)**
Esta definida por los siguientes criterios:

1.   Total de Alojamientos (TA)
2.   Distribucion por categoria (DC)
3.   Proximidad media al centro (PC)
4.   Proporcion de alojamientos con servicios criticos (SC)

La ponderación de este criterio se dará de la siguiente manera:

CH = 0.4TA + 0.25DC + 0.25PC + 0.1SC




"""

#1. Total Alojamientos (TA)
TA = df.groupby('destino')["title"].count().rename("TA")
TA

"""Descripción de qué tan equitativa es la distribución de los alojamientos por cada categoría de precios. En otras palabras, un valor cercano a 1 indica una distribución más balanceada, la misma cantidad de alojamientos entre cada categoría. Adicional, se detalla la proporción de alojamientos por categoría para cada destino:"""

#2. Distribucion por categoria (DC)
cat_counts = df.groupby(["destino", "categoria"])["title"].count().unstack().fillna(0)
DC = 1 - (cat_counts.max(axis=1) - cat_counts.min(axis=1)) / cat_counts.sum(axis=1)
DC.name = "DC"
proportion_by_category = cat_counts.div(cat_counts.sum(axis=1), axis=0)
combined_cats = pd.concat([proportion_by_category, DC], axis=1)
display(combined_cats)

"""Aquí tienes una tabla que muestra la distancia media al centro (`dist_mean`) y la proximidad media al centro (`PC`) para cada destino:"""

#3. Proximidad media al centro (PC)
dist_mean = df.groupby("destino")["dist_centro_km"].mean()
PC = 1 - (dist_mean - dist_mean.min()) / (dist_mean.max() - dist_mean.min())
PC.name = "PC"
combined_distances = pd.concat([dist_mean, PC], axis=1)
display(combined_distances)

#4. Proporcion de alojamientos con servicios criticos (SC)
SC = (
    (df.groupby("destino")["pool"].mean() +
     df.groupby("destino")["breakfast"].mean() +
     df.groupby("destino")["beachfront"].mean()) / 3
).rename("SC")
SC

# Normalización 0–1
CH_df = pd.concat([TA, DC, PC, SC], axis=1)
CH_norm = (CH_df - CH_df.min()) / (CH_df.max() - CH_df.min())

CH_df["CH"] = (
    0.40 * CH_norm["TA"] +
    0.25 * CH_norm["DC"] +
    0.25 * CH_norm["PC"] +
    0.1 * CH_norm["SC"]
)
CH_df

"""**Nivel de Hospitalidad (NH)**
Esta definida con base a las ponderaciones de los siguientes criterios:
1.   Analisis de sentimiento (HF)
2.   Hospitality Experience Score (HES)
3.   Rating promedio del destino (RP)
4.   Mediana del rating (MR)

La ponderación de este criterio se dará de la siguiente forma:

CH = 0.25HF + 0.2HES + 0.2MR + 0.35RP
"""

# Extraer reseñas a un DF
rev_rows = []
for _, row in df.iterrows():
    for r in row["reviews"]:
        text = (r.get("positive_feedback", "") or "") + " " + (r.get("negative_feedback", "") or "")
        rev_rows.append({"destino": row["destino"], "review": text})

reviews = pd.DataFrame(rev_rows)
reviews

#1. Rating promedio del destino (RP) y 2. Mediana del rating (MR)
RP = df.groupby("destino")["rating"].mean().rename("RP")
MR = df.groupby("destino")["rating"].median().rename("MR")
Rating = pd.concat([RP, MR], axis=1)
Rating

#3. Analisis de sentimiento (HF)

#4. Hospitality Experience Score (HES)

"""**Relacion Calidad-Precio (RCP)**
Esta definida con base a las ponderaciones de los siguientes criterios:
1.   Precio promedio por categoria (PPC)
2.   Precio vs. Rating (PVR)
3.   Dispersion de precios (DP)

La ponderación de este criterio se dará de la siguiente manera:

CH = 0.4PPC + 0.35PVR + 0.25DP  
"""

#1. Precio promedio por categoria (PPC)

#2. Precio vs. Rating (PVR)

#3. Dispersion de precios (DP)